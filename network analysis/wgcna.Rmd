```{r input.file.prep}
options(stringsAsFactors = FALSE)
df <- read.table("WGCNA input_log2fc.txt", header=TRUE, sep ="\t")
dim(df)
names(df)
rnames <- df[,1]
rnames
rownames(df) <- rnames
DEGs <- df
names(DEGs)
datExpr = as.data.frame(t(DEGs[, -c(1)]))
View(datExpr)
dim(datExpr)
```

```{r input.file.prep}
# We first check for genes and samples with too many missing values:
gsg = goodSamplesGenes(datExpr, verbose = 3);
gsg$allOK
# If the last statement returns TRUE, all genes have passed the cuts. If not, we remove the offending genes and samples from the data:
if (!gsg$allOK)
{
  # Optionally, print the gene and sample names that were removed:
  if (sum(!gsg$goodGenes)>0)
     printFlush(paste("Removing genes:", paste(names(datExpr)[!gsg$goodGenes], collapse = ", ")));
  if (sum(!gsg$goodSamples)>0)
     printFlush(paste("Removing samples:", paste(rownames(datExpr)[!gsg$goodSamples], collapse = ", ")));
  # Remove the offending genes and samples from the data:
  datExpr = datExpr[gsg$goodSamples, gsg$goodGenes]
}
```


```{r WGCNA_Power}
# Choose a set of soft-thresholding power
powers = c(c(1:10), seq(from = 12, to=40, by=2))
# Call the network topology analysis function
# sft=pickSoftThreshold(datExpr,dataIsExpr=TRUE, powerVector=powers, corFnc=cor, corOptions=list(use='p', method='spearman'), networkType="signed", verbose = 5)
# above script made computer frozen
sft=pickSoftThreshold(datExpr, powerVector=powers, networkType="signed", verbose = 5)
## link for unsigned or signed http://www.peterlangfelder.com/signed-or-unsigned-which-network-type-is-preferable/

# Plot the results:
sizeGrWindow(9, 5)
par(mfrow = c(1,2))
cex1 = 0.9

# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit, signed R^2",type="n", main = paste("Scale independence"))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],labels=powers,cex=cex1,col="red")
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")

# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
```


```{r WGCNA_Power}
# We now calculate the adjacencies, using the soft thresholding power 18:
## generating adjacency and TOM similarity matrices based on the selected softpower
softPower = 18
## calcluate the adjacency matrix
adjacency= adjacency(datExpr,type = "signed", power = softPower)
# Turn adjacency into topological overlap
TOM = TOMsimilarity(adjacency);
dissTOM = 1-TOM

# Clustering using TOM
## We now use hierarchical clustering to produce a hierarchical clustering tree (dendrogram) of genes. Note that we use the function hclust that provides a much faster hierarchical clustering routine than the standard hclust function.
# Call the hierarchical clustering function
geneTree = flashClust(as.dist(dissTOM),method="average")

# plot the resulting clustering tree (dendrogram)
sizeGrWindow(12,9)
plot(geneTree, xlab="", sub="", main = "Gene clustering on TOM-based dissimilarity",
    labels = FALSE, hang = 0.04);

# Set the minimum module size
minModuleSize = 30;

# Module identification using dynamic tree cut
dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM,
              deepSplit = 2, pamRespectsDendro = FALSE,
              minClusterSize = minModuleSize);
# the following command gives the module labels and the size of each module. Lable 0 is reserved for unassigned genes. lagrgest to smallest
table(dynamicMods) # Label 0 is reserved for unassigned genes.
```


```{r plot}
# We now plot the module assignment under the gene dendrogram:
# Plot the module assignment under the dendrogram; note: The grey color is reserved for unassigned genes
# Convert numeric lables into colors
dynamicColors = labels2colors(dynamicMods)
table(dynamicColors)
# Plot the dendrogram and colors underneath
sizeGrWindow(8,6)
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut", dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05, main = "Gene dendrogram and module colors")
```


```{r merging}
# Calculate eigengenes
MEList = moduleEigengenes(datExpr, colors = dynamicColors)
MEs = MEList$eigengenes
# Calculate dissimilarity of module eigengenes
MEDiss = 1-cor(MEs);
# Cluster module eigengenes
METree = hclust(as.dist(MEDiss), method = "average");
# Plot the result
sizeGrWindow(7, 6)
plot(METree, main = "Clustering of module eigengenes",
     xlab = "", sub = "")

# We choose a height cut of 0.25, corresponding to correlation of 0.75, to merge
MEDissThres = 0.25
# Plot the cut line into the dendrogram
abline(h=MEDissThres, col = "red")
# Call an automatic merging function
merge = mergeCloseModules(datExpr, dynamicColors, cutHeight = MEDissThres, verbose = 3)
# The merged module colors
mergedColors = merge$colors;
# Eigengenes of the new merged modules:
mergedMEs = merge$newMEs;


# To see what the merging did to our module colors, we plot the gene dendrogram again, with the original and merged module colors underneath
sizeGrWindow(12, 9)
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),
                   c("Dynamic Tree Cut", "Merged dynamic"),
                   dendroLabels = FALSE, hang = 0.03,
                   addGuide = TRUE, guideHang = 0.05)

pdf(file = "8678 DEGs_root_dendrogram.pdf", width = 7, height = 6) # defaults to 7 x 7 inches
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),
                   c("Dynamic Tree Cut", "Merged dynamic"),
                   dendroLabels = FALSE, hang = 0.03,
                   addGuide = TRUE, guideHang = 0.05)
dev.off()

# In the subsequent analysis, we will use the merged module colors in mergedColors. We save the relevant variables for use in subsequent parts of the tutorial:
# Rename to moduleColors
moduleColors = mergedColors
```
